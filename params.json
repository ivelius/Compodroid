{"name":"Compodroid","tagline":"Architectural Android Framework.","body":"## What is Compodroid ?\r\nCompodroid is an [Android](https://www.android.com/) library that allows you to scatter your code around target specific \"components\" , rather than writing the code inside the target class itself. Compodroid turns any class into a \"set of components\" that operate independently allowing hight level of code modularity. Being design specifically with Android in mind , Compodroid has a build in support for all [Android](https://www.android.com/) core elements such as : [Activities](http://developer.android.com/reference/android/app/Activity.html) , [Fragments](http://developer.android.com/reference/android/app/Fragment.html) , [Services](http://developer.android.com/reference/android/app/Service.html) , [Broadcast Recievers](http://developer.android.com/reference/android/content/BroadcastReceiver.html) ,etc... \r\n\r\n## Why to use Compodroid ?\r\nThere are 2 common scenarios in which your project can benefit from Compodroid .\r\n\r\n### Complicated One Screen App\r\nImagine you have a single screen app , which is contains a ViewPager , a sliding drawer , navigation tabs and deep drill down hierarchy for each pager view screen. While you will try to organize your functionality across one _Host_ Activity and many fragments in it , you will soon realize that there is too much code to put into the _Host_ Activity ,and you will naturally scatter the functionality across different classes that cooperate with your _Host_ Activity . In regards to your fragments , they will probably have a lot of similarities and you will try to reuse code by subclasing a _BaseFragment_ and to put more code into it that actually every subclassing Fragment needs. \r\nThis is an example when Compodroid is naturally improving your code organization. _Host_ Activity can be broken into \"Components\" where each component will define a \"feature\" or a functionality. The same is true for fragments. Instead of subclassing a _BaseFragment_ (which is still possible with Compodroid) , you will add components to each fragment that actually needs them . In such a way you will not only reuse your code but will also save a memory by not loading methods of a superclass that you don't actually need.\r\n\r\n### Deep Activities/Fragments Hierarchy\r\nImagine you have BaseFragment that have some common functionality to all your fragments.You extend it to have a \"PopupFragment\" \"ToastFragment\" and a \"BadgeFragment\" . Now Both \"PopupFragment\" and \"ToastFragment\" can appear with animation into a screen. You would like to write your animation code somewhere once and reuse it everywhere it is needed. But writing the code in \"BaseFragment\" will actually cause a badge fragment to also appear with animation. So you decide to extend the base fragment with \"AbstractAnimatableFragment\" and use it as a superclass of your \"PopupFragment\" and \"ToastFragment\". Well done ! Now what if both \"ToastFragment\" and \"BadgeFragment\" can auto disappear after 5 seconds. Will you create a subclass of \"BaseFragment\" and then \"DissapearableFragment\" for a \"BadgeFragment\" , and then \"AnimatableDissapearableFragment\" and use it for \"ToastFragment\" ? You see where it is going right ? Rather than bloating your project with a special subclass for every case , you can just encapsulate your desired functionality in \"AppearableFragmentComponent\" and \"DissapearableFragmentComponent\". And attach those to fragments that need it.\r\n\r\n\r\n## Are there more benefits using Compodroid ?\r\n\r\n## Compodroid Architecture\r\nCompodroid main idea is to stay simple and thin , while highly scalable.\r\nBasically the entire library is [this](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib/src/main/java/com/yan/compodroid/core) simple package. Everything else is just an extension of the core concept.\r\nTo make Compodroid [Android](https://www.android.com/) friendly ,the main extensions are [Compodroid Activity](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib/src/main/java/com/yan/compodroid/activity) and [Compodroid Fragment](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib/src/main/java/com/yan/compodroid/fragment) packages. Those extensions are built in into [compodroid-lib](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib).\r\n\r\n### Component Manager\r\nThe Component Manager main purpose is to delegate methods from the class that holds it to the actual components that were added to the Component Manager. Component Manager is created to serve a single instance of a class (reffered as a _Target_) . All components that are added to the Component Manager , must target the same class as the Component Manager (not necessary the same instance).\r\n\r\n### Component\r\nIs a peace of logic that can be added to Component Manager. Component will receive events from Component Manager that it is attached to. Amount of events or callback methods will vary depending on the Component Manager .\r\nThe Component also have a _Target_ and can be added **only** to Managers that targeting the same _Target_ class as the component.\r\n\r\n## How to use Compodroid ?\r\nHave a look at [examples](https://github.com/ivelius/Compodroid/tree/master/app/src/main/java/com/yan/compodroidtest).\r\n\r\n\r\n\r\n\r\n## Adding Compodroid \"Plugins\"\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.\r\n\r\n## Creating your own components\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}