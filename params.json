{"name":"Compodroid","tagline":"Architectural Android Framework.","body":"## What is Compodroid ?\r\nCompodroid is an [Android](https://www.android.com/) library that allows you to scatter your code around target specific \"components\" , rather than writing the code inside the target class itself. Compodroid turns any class into a \"set of components\" that operate independently allowing hight level of code modularity. Being design specifically with Android in mind , Compodroid has a build in support for all [Android](https://www.android.com/) core elements such as : [Activities](http://developer.android.com/reference/android/app/Activity.html) , [Fragments](http://developer.android.com/reference/android/app/Fragment.html) , [Services](http://developer.android.com/reference/android/app/Service.html) , [Broadcast Recievers](http://developer.android.com/reference/android/content/BroadcastReceiver.html) ,etc... \r\n\r\n## Why to use Compodroid ?\r\nThere are 2 common scenarios in which your project can benefit from Compodroid .\r\n\r\n### Complicated One Screen App\r\nImagine you have a single screen app , which is contains a ViewPager , a sliding drawer , navigation tabs and deep drill down hierarchy for each pager view screen. While you will try to organize your functionality across one _Host_ Activity and many fragments in it , you will soon realize that there is too much code to put into the _Host_ Activity ,and you will naturally scatter the functionality across different classes that cooperate with your _Host_ Activity . In regards to your fragments , they will probably have a lot of similarities and you will try to reuse code by subclasing a _BaseFragment_ and to put more code into it that actually every subclassing Fragment needs. \r\nThis is an example when Compodroid is naturally improving your code organization. _Host_ Activity can be broken into \"Components\" where each component will define a \"feature\" or a functionality. The same is true for fragments. Instead of subclassing a _BaseFragment_ (which is still possible with Compodroid) , you will add components to each fragment that actually needs them . In such a way you will not only reuse your code but will also save a memory by not loading methods of a superclass that you don't actually need.\r\n\r\n### Deep Activities/Fragments Hierarchy\r\nImagine you have a BaseFragment that have some common functionality to all of your fragments.You extend it to have a _PopupFragment_ , _ToastFragment_ and a _BadgeFragment_ . Now Both _PopupFragment_ and a _ToastFragment_ can appear with animation. You would like to write your animation code somewhere once and reuse it everywhere where it is needed. But writing the code in the _BaseFragment_ will actually cause a _BadgeFragment_ to also appear with animation. So you decide to extend the base fragment with _AbstractAnimatableFragment_ and use it as a superclass of your _PopupFragment_ and _ToastFragment_. Well done ! Now what if both _ToastFragment_ and _BadgeFragment_ can auto disappear after 5 seconds. Will you create a subclass of _BaseFragment_ as a _DissapearableFragment_ for a _BadgeFragment_ , and then _AnimatableDissapearableFragment_ and use it for _ToastFragment_ ? You see where it is going right ? Rather than bloating your project with a special subclass for every case , you can just encapsulate your desired functionality in _AppearableFragmentComponent_ and _DissapearableFragmentComponent_. And attach those to fragments that need it.\r\n\r\n\r\n## Are there more benefits using Compodroid ?\r\nCertainly.\r\n* One of the biggest advantages is modularity of your code. A component done right is a component that can be added or removed at any given time. Hence , you will always have a chance to add or remove functionality on the fly to/from your target. \r\n* A component can be _multi targeted_ .Component created for one target can be translated to another target using [ComponentAdapter](https://github.com/ivelius/Compodroid/blob/master/compodroid-lib/src/main/java/com/yan/compodroid/core/CompodroidComponentAdapter.java).That allows you to reuse the same functionality across all of your classes , as long as you can adapt them in a manner that makes sense to you.\r\n* Compodroid aims to be community driven. There might be already plug and play solution to your problem that is provided as a _Compodroid plugin package_ . As an example see [injections-pack](https://github.com/ivelius/Compodroid/tree/master/injections-pack) .\r\n* Fast iteration can be achieved through encapsulating \"features\" into components. If at some point you decide that you need to remove/disable a feature of your app , simply detach the component from your target. For example the entire flow of Login with Facebook can be encapsulated into a ActivityComponent . When you no longer want this feature , simply detach the component . If you no longer want it ever , you can delete one file of the component and forget this feature ever existed.\r\n\r\n## Compodroid Architecture\r\nCompodroid main idea is to stay simple and thin , while highly scalable.\r\nBasically the entire library is [this](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib/src/main/java/com/yan/compodroid/core) simple package. Everything else is just an extension of the core concept.\r\nTo make Compodroid [Android](https://www.android.com/) friendly ,the main extensions are [Compodroid Activity](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib/src/main/java/com/yan/compodroid/activity) and [Compodroid Fragment](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib/src/main/java/com/yan/compodroid/fragment) packages. Those extensions are built in into [compodroid-lib](https://github.com/ivelius/Compodroid/tree/master/compodroid-lib).\r\n\r\n### Component Manager\r\nThe Component Manager main purpose is to delegate methods from the class that holds it to the actual components that were added to the Component Manager. Component Manager is created to serve a single instance of a class (reffered as a _Target_) . All components that are added to the Component Manager , must target the same class as the Component Manager (not necessary the same instance).\r\n\r\n### Component\r\nIs a peace of logic that can be added to Component Manager. Component will receive events from Component Manager that it is attached to. Amount of events or callback methods will vary depending on the Component Manager .\r\nThe Component also have a _Target_ and can be added **only** to Managers that targeting the same _Target_ class as the component.\r\n\r\n## How to use Compodroid ?\r\nMake sure to add jcenter as a maven repository to your main build.gradle.\r\nFor compodroid lib :\r\n**compile 'com.yan.compodroid:compodroid-lib:0.0.3-ALPHA'**\r\n\r\nCompodroid plugin packages should be added separatley.\r\nFor example _injections-pack_ :\r\n**compile 'com.yan.compodroid:injections-pack:0.0.2-BETA'**\r\n\r\nTo understand better how Compodroid is used , make sure to check the [examples](https://github.com/ivelius/Compodroid/tree/master/app/src/main/java/com/yan/compodroidtest).\r\n\r\n\r\n\r\n\r\n## Adding Compodroid \"Plugins\"\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.\r\n\r\n## Creating your own components\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}